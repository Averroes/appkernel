from flask import Flask, jsonify, current_app, request
from model import Model
from appkernel import AppKernelEngine
from appkernel.repository import Repository, xtract
from reflection import *
import traceback, sys


class Service(object):
    pretty_print = True
    """
    The Flask App is set on this instance, so one can use the context:
    with self.app_context():
        some_varibale = some_context_aware_function()
    """

    @classmethod
    def set_app_engine(cls, app_engine, url_base):
        """
        :param url_base: the url where the service is exposed
        :type url_base: basestring
        :param app_engine: the app kernel engine
        :type app_engine: AppKernelEngine
        :return:
        """
        cls.app = app_engine.app
        cls.app_engine = app_engine
        if not url_base.endswith('/'):
            url_base = '{}/'.format(url_base)
        endpoint = '{}{}'.format(url_base, xtract(cls).lower())
        if issubclass(cls, Repository) and 'find_by_id' in dir(cls):
            # generate get by id
            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'get_by_id_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.find_by_id),
                                 methods=['GET'])

            cls.app.add_url_rule('{}'.format(endpoint), 'post_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.create_object),
                                 methods=['POST'])

            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'put_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.replace_object),
                                 methods=['PUT'])

            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'patch_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.update_object),
                                 methods=['PATCH'])

            cls.app.add_url_rule('{}'.format(endpoint), 'get_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.find_by_id),
                                 methods=['GET'])
            # generate delete by id
            cls.app.add_url_rule('{}/<object_id>'.format(endpoint), 'delete_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.delete_by_id),
                                 methods=['DELETE'])

    @classmethod
    def execute(cls, app_engine, provisioner_method):
        """
        :param app_engine: the app engine instance
        :param provisioner_method: the method on our service object which will be executed by the Flask reflection
        :return: the result generated by the service
        """

        def is_basic(obj):
            return is_primitive(obj) or is_noncomplex(obj) or isinstance(obj, (str, basestring))

        def create_executor(**named_args):
            try:
                print('named args: {}'.format(named_args))
                print '>>> current app name: {}'.format(current_app.name)
                print 'current object: {}'.format(current_app._get_current_object())
                print 'Request method: {}'.format(request.method)
                print 'request form: {}'.format(request.form)
                print 'request args: {}'.format(request.args)
                #todo: continue it here
                #request.form | request.args | request.files
                #request.values: combined args and form, preferring args if keys overlap
                print 'request json {}'.format(request.json)

                # merge together the named args (url parameters) and the query parameters (from requests.args)
                named_and_request_arguments = named_args.copy()
                named_and_request_arguments.update(request.args)

                if request.method in ['POST', 'PUT', 'PATCH']:
                    named_args.update(document=Model.loads(request.json))
                result = provisioner_method(**named_and_request_arguments)
                # request.args.get('key', '')
                result_dic_tentative = Service.xvert(result) if result else {}
                if is_basic(result_dic_tentative):
                    result_dic_tentative = {'result': result_dic_tentative}
                return jsonify(result_dic_tentative), 200
            except Exception as exc:
                app_engine.logger.exception('exception caught while executing service call: {}'.format(str(exc)))
                return app_engine.generic_error_handler(exc)

        return create_executor

    @staticmethod
    def xvert(result_item):
        if isinstance(result_item, Model):
            return Model.to_dict(result_item)
        elif is_dictionary(result_item) or is_dictionary_subclass(result_item):
            return result_item
        elif isinstance(result_item, (list, set, tuple)):
            return [Service.xvert(item) for item in result_item]
        elif is_primitive(result_item) or isinstance(result_item, (str, basestring)) or is_noncomplex(result_item):
            return result_item

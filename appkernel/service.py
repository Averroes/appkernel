from flask import Flask, jsonify, current_app, request, abort
from werkzeug.datastructures import MultiDict
from model import Model
from appkernel import AppKernelEngine
from appkernel.repository import Repository, xtract
from reflection import *
from model import Expression
import re
from collections import defaultdict
import traceback, sys
import inspect


class QueryProcessor(object):
    def __init__(self):
        self.query_pattern = re.compile('^(\w+:[\[\],\<\>A-Za-z0-9_\s-]+)(,\w+:[\[\],\<\>A-Za-z0-9_\s-]+)*$')
        self.expression_mapper = {
            '<': lambda exp: ('$lt', exp),
            '>': lambda exp: ('$gte', exp),
            '~': lambda exp: '\.*{}.*\i'.format(exp)
        }
        self.supported_expressions = list(self.expression_mapper.keys())


class Service(object):
    pretty_print = True
    qp = QueryProcessor()
    """
    The Flask App is set on this instance, so one can use the context:
    with self.app_context():
        some_varibale = some_context_aware_function()
    """

    @classmethod
    def set_app_engine(cls, app_engine, url_base, methods):
        """
        :param methods: the HTTP methods allowed for this service
        :param url_base: the url where the service is exposed
        :type url_base: basestring
        :param app_engine: the app kernel engine
        :type app_engine: AppKernelEngine
        :return:
        """
        cls.app = app_engine.app
        cls.app_engine = app_engine
        if not url_base.endswith('/'):
            url_base = '{}/'.format(url_base)
        endpoint = '{}{}'.format(url_base, xtract(cls).lower())
        class_methods = dir(cls)
        if issubclass(cls, Repository) and 'GET' in methods:
            # generate get by id
            if 'find_by_query' in class_methods:
                cls.app.add_url_rule('{}/'.format(endpoint), 'get_{}'.format(endpoint),
                                     Service.execute(app_engine, cls.find_by_query, cls),
                                     methods=['GET'])
            if 'find_by_id' in class_methods:
                cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'get_by_id_{}'.format(endpoint),
                                     Service.execute(app_engine, cls.find_by_id, cls),
                                     methods=['GET'])
        if issubclass(cls, Repository) and 'save_object' in class_methods and 'POST' in methods:
            cls.app.add_url_rule('{}/'.format(endpoint), 'post_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.save_object, cls),
                                 methods=['POST'])
        if issubclass(cls, Repository) and 'replace_object' in class_methods and 'PUT' in methods:
            cls.app.add_url_rule('{}/'.format(endpoint), 'put_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.replace_object, cls),
                                 methods=['PUT'])
        if issubclass(cls, Repository) and 'save_object' in class_methods and 'PATCH' in methods:
            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'patch_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.save_object, cls),
                                 methods=['PATCH'])

        if issubclass(cls, Repository) and 'delete_by_id' in class_methods and 'DELETE' in methods:
            cls.app.add_url_rule('{}/<object_id>'.format(endpoint), 'delete_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.delete_by_id, cls),
                                 methods=['DELETE'])

    @classmethod
    def execute(cls, app_engine, provisioner_method, model_class):
        """
        :param app_engine: the app engine instance
        :param provisioner_method: the method on our service object which will be executed by the Flask reflection
        :param model_class: the class of the model
        :return: the result generated by the service
        """

        def create_executor(**named_args):
            try:
                # print('named args: {}'.format(named_args))
                # print '>>> current app name: {}'.format(current_app.name)
                # print 'current object: {}'.format(current_app._get_current_object())
                # print 'Request method: {}'.format(request.method)
                # print 'request form: {}'.format(request.form)
                # print 'request args: {}'.format(request.args)
                # #todo: continue it here
                # #request.form | request.args | request.files
                # #request.values: combined args and form, preferring args if keys overlap
                # print 'request json {}'.format(request.json)

                # merge together the named args (url parameters) and the query parameters (from requests.args)
                named_and_request_arguments = named_args.copy()

                # extract the query parameters and add to a generic parameter dictionary
                if isinstance(request.args, MultiDict):
                    # Multidict is a werkzeug only type
                    for arg in request.args:
                        query_item = {arg: request.args.get(arg)}
                        named_and_request_arguments.update(query_item)
                else:
                    named_and_request_arguments.update(request.args)

                if 'query' in named_and_request_arguments:
                    # in case we have a query parameter we should process it
                    named_and_request_arguments.update(
                        query=Service.convert_to_query(named_and_request_arguments.get('query')))

                if request.method in ['POST', 'PUT']:
                    # load and validate the posted object
                    model_instance = Model.from_dict(request.json, model_class)
                    # save or update the object
                    named_and_request_arguments.update(document=Model.to_dict(model_instance, convert_id=True))
                elif request.method == 'PATCH':
                    named_and_request_arguments.update(document=request.json)

                result = provisioner_method(
                    **Service.__autobox_parameters(provisioner_method, named_and_request_arguments))
                if request.method == 'GET' and result is None:
                    return app_engine.create_custom_error(404, 'Document with id {} is not found.'.format(
                        named_args.get('object_id', '-1')))
                if request.method == 'DELETE' and isinstance(result, int) and result == 0:
                    return app_engine.create_custom_error(404, 'Document with id {} was not deleted.'.format(
                        named_args.get('object_id', '-1')))
                result_dic_tentative = {} if result is None else Service.xvert(result)
                return jsonify(result_dic_tentative), 200
            except Exception as exc:
                app_engine.logger.exception('exception caught while executing service call: {}'.format(str(exc)))
                return app_engine.generic_error_handler(exc)

        return create_executor

    def __convert_to_query(self, query, logic=Expression.OPS.AND):
        """
        ?query=first_name:{firstName},last_name:{lastName},birth_date:{birthDate}
        Supported query formats:
        The value of first_name, last_name and birth_date is exactly the ones in the list.
        Converted to:
        {"$and":[
            {"first_name":{firstName}},
            {"last_name":{lastName}},
            {"birth_date":{birthDate}}
            ]}

        ?first_name:~{firstName}
        The first name contains a given value;
        Converted to:
        {"first_name" : "/.*{firstName}.*/i"}

        ?birth_date=>{birthDate}
        Birth date after the given parameter (inclusive >=)
        Converted to:
        {"birth_date": {$gte:{birthDate}}}

        ?birth_date:>{birthDate}&?birth_date:<{birthDate}
        Birth date between the two parameters, with date pattern matching if applies.
        Converted to:
        {"birth_date": [{$gte:{birthDate},{"$lt":{birthDate}}]}}


        ?state:[NEW, CLOSED]
        The state of a give content among the provided patterns.
        Converted to:
        {"state":{"$in":["NEW", "CLOSED"]}}
        :param logic: AND or OR, which applies to the query parameters
        :param query: the query expression, like "first_name:{firstName},last_name:{lastName},birth_date:{birthDate}"
        :type query: str
        :return:
        """

        if not Service.qp.query_pattern.match(query):
            raise ValueError(
                'The provided query expression ({}) is not in the accepted format (comma separated groups with colon separated key value pairs)'.format(
                    query))
        groups = [tuple(group.split(':')) for group in query.split(',')]
        query_dict = defaultdict(list)
        for group in groups:
            query_dict[group[0]].append(group[1])

        expression_list = []
        for query_item in [[key, val] for key, val in query_dict.iteritems()]:
            # where query_item[0] is the key of the future structure nad query_item[1] is the value
            if isinstance(query_item[1], list) and len(query_item[1]) > 1:
                # it is a key with a list of values
                expression_list.append(
                    {query_item[0]: dict([self.__remap_expressions(expr) for expr in query_item[1]])})
            else:
                # it is a key with a list of only 1 item
                mapped_value = self.__remap_expressions(query_item[1][0])
                if isinstance(mapped_value, tuple):
                    expression_list.append({query_item[0]: dict([mapped_value])})
                else:
                    expression_list.append({query_item[0]: mapped_value})

        if len(expression_list) == 0:
            return {}
        elif len(expression_list) == 1:
            # the dictionary has 0 or 1 elements
            return expression_list[0]
        else:
            return {logic: expression_list}

    def __remap_expressions(self, expression):
        if expression[0] in Service.qp.supported_expressions:
            return Service.qp.expression_mapper.get(expression[0])(expression[1:])
        else:
            return expression

    @staticmethod
    def __autobox_parameters(provisioner_method, arguments):
        # argspec = inspect.getargspec(provisioner_method)
        # returns a dict with the call argument names and default values
        argspec = inspect.getcallargs(provisioner_method)
        for arg_key, arg_value in arguments.iteritems():
            required_type = type(argspec.get(arg_key))
            provided_type = type(arg_value)
            if required_type and required_type != provided_type:
                arguments[arg_key] = required_type(arg_value)
        return arguments

    @staticmethod
    def xvert(result_item):
        if isinstance(result_item, Model):
            return Model.to_dict(result_item)
        elif is_dictionary(result_item) or is_dictionary_subclass(result_item):
            return result_item
        elif isinstance(result_item, (list, set, tuple)):
            return [Service.xvert(item) for item in result_item]
        elif is_primitive(result_item) or isinstance(result_item, (str, basestring, int)) or is_noncomplex(result_item):
            return {'result': result_item}

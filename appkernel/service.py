from flask import Flask, jsonify, current_app, request, abort
from model import Model
from appkernel import AppKernelEngine
from appkernel.repository import Repository, xtract
from reflection import *
import traceback, sys


class Service(object):
    pretty_print = True
    """
    The Flask App is set on this instance, so one can use the context:
    with self.app_context():
        some_varibale = some_context_aware_function()
    """

    @classmethod
    def set_app_engine(cls, app_engine, url_base):
        """
        :param url_base: the url where the service is exposed
        :type url_base: basestring
        :param app_engine: the app kernel engine
        :type app_engine: AppKernelEngine
        :return:
        """
        cls.app = app_engine.app
        cls.app_engine = app_engine
        if not url_base.endswith('/'):
            url_base = '{}/'.format(url_base)
        endpoint = '{}{}'.format(url_base, xtract(cls).lower())
        if issubclass(cls, Repository) and 'find_by_id' in dir(cls):
            # generate get by id
            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'get_by_id_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.find_by_id, cls),
                                 methods=['GET'])

            cls.app.add_url_rule('{}/'.format(endpoint), 'post_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.save_object, cls),
                                 methods=['POST'])

            cls.app.add_url_rule('{}/'.format(endpoint), 'put_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.replace_object, cls),
                                 methods=['PUT'])

            cls.app.add_url_rule('{}/<string:object_id>'.format(endpoint), 'patch_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.save_object, cls),
                                 methods=['PATCH'])

            cls.app.add_url_rule('{}'.format(endpoint), 'get_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.find_by_id, cls),
                                 methods=['GET'])
            # generate delete by id
            cls.app.add_url_rule('{}/<object_id>'.format(endpoint), 'delete_{}'.format(endpoint),
                                 Service.execute(app_engine, cls.delete_by_id, cls),
                                 methods=['DELETE'])

    # todo: not found when ids not found

    @classmethod
    def execute(cls, app_engine, provisioner_method, model_class):
        """
        :param app_engine: the app engine instance
        :param provisioner_method: the method on our service object which will be executed by the Flask reflection
        :param model_class: the class of the model
        :return: the result generated by the service
        """

        def create_executor(**named_args):
            try:
                # print('named args: {}'.format(named_args))
                # print '>>> current app name: {}'.format(current_app.name)
                # print 'current object: {}'.format(current_app._get_current_object())
                # print 'Request method: {}'.format(request.method)
                # print 'request form: {}'.format(request.form)
                # print 'request args: {}'.format(request.args)
                # #todo: continue it here
                # #request.form | request.args | request.files
                # #request.values: combined args and form, preferring args if keys overlap
                # print 'request json {}'.format(request.json)

                # merge together the named args (url parameters) and the query parameters (from requests.args)
                named_and_request_arguments = named_args.copy()
                named_and_request_arguments.update(request.args)

                if request.method in ['POST', 'PUT']:
                    # load and validate the posted object
                    model_instance = Model.from_dict(request.json, model_class)
                    # save or update the object
                    named_and_request_arguments.update(document=Model.to_dict(model_instance, convert_id=True))
                elif request.method == 'PATCH':
                    named_and_request_arguments.update(document=request.json)
                result = provisioner_method(**named_and_request_arguments)
                if request.method == 'GET' and result is None:
                    return app_engine.create_custom_error(404, 'Document with id {} is not found.'.format(
                        named_args.get('object_id', '-1')))
                if request.method == 'DELETE' and isinstance(result, int) and result == 0:
                    return app_engine.create_custom_error(404, 'Document with id {} was not deleted.'.format(
                        named_args.get('object_id', '-1')))
                result_dic_tentative = {} if result is None else Service.xvert(result)
                return jsonify(result_dic_tentative), 200
            except Exception as exc:
                app_engine.logger.exception('exception caught while executing service call: {}'.format(str(exc)))
                return app_engine.generic_error_handler(exc)

        return create_executor

    @staticmethod
    def xvert(result_item):
        if isinstance(result_item, Model):
            return Model.to_dict(result_item)
        elif is_dictionary(result_item) or is_dictionary_subclass(result_item):
            return result_item
        elif isinstance(result_item, (list, set, tuple)):
            return [Service.xvert(item) for item in result_item]
        elif is_primitive(result_item) or isinstance(result_item, (str, basestring, int)) or is_noncomplex(result_item):
            return {'result': result_item}
